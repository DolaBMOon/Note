http://www.yhzq-blog.cc/
http://mirrors.ustc.edu.cn/
https://tuna.moe/
telnet towel.blinkenlights.nl //Star Wars!!
https://raw.githubusercontent.com/bannedbook/fanqiang/master/jw/new.pac //You may need to take this site as a key"pac.dtwang.org"
https://github.com/bannedbook/fanqiang

#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<vector>
using namespace std;
const int MAXN=100000;
const int MAXM=100000;
const int INF=100000;
int n,m;
vector<int> G[MAXN+10];
//SHULIANPOUFEN
int c_0,l_0,c_1,r_1;
int tmp[MAXN+10];
int col[MAXN+10],dep[MAXN+10],siz[MAXN+10],hson[MAXN+10],top[MAXN+10],fa[MAXN+10],dfn[MAXN+10],dfsTime;
//SegmentTree
int t[4*MAXN+10],col_0[4*MAXN+10],col_1[4*MAXN+10],lazy[4*MAXN+10];
void build(int o,int l,int r)
{
	if(l==r)
	{
		t[o]=1;
		col_0[o]=col_1[o]=col[l];
		return;
	}
	int mid=(l+r)>>1,lc=o<<1,rc=(o<<1)+1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	col_0[o]=col_0[lc];
	col_1[o]=col_1[rc];
}
void PushDown(int o,int l,int r)
{
	if(lazy[o]==-1)return;
	int lc=o<<1,rc=(o<<1)+1;
	t[lc]=t[rc]=1;
	col_0[lc]=col_0[rc]=col_1[lc]=col_1[rc]=lazy[o];
	lazy[o]=-1;
}
void update(int o,int l,int r,int ql,int qr,int w)
{
	if(l==ql&&r==qr)
	{
		t[o]=1;col_0[o]=w;col_1[o]=w;lazy[o]=w;
		return;
	}
	PushDown(o,l,r);
	int mid=(l+r)>>1,lc=o<<1,rc=(o<<1)+1;
	if(qr<=mid)update(lc,l,mid,ql,qr,w);
	else if(ql>mid)update(rc,mid+1,r,ql,qr,w);
	else
	{
		update(lc,l,mid,ql,mid,w);
		update(rc,mid+1,r,mid+1,qr,w);
	}
	t[o]=t[lc]+t[rc]-(col_1[lc]==col_0[rc]);
	col_0[o]=col_0[lc];col_1[o]=col_1[rc];
}
int query(int o,int l,int r,int ql,int qr)
{
	if(l==qr&&r==qr)
	{
		if(l<l_0)c_0=col_0[o];
		if(r>r_1)c_1=col_1[o];
		return t[o];
	}
	PushDown(o,l,r);
	int mid=(l+r)>>1,lc=o<<1,rc=(o<<1)+1;
	if(qr<=mid)return query(lc,l,mid,ql,qr);
	else if(ql>mid)return query(rc,mid+1,r,ql,qr);
	else return query(lc,l,mid,ql,mid)+query(rc,mid+1,r,mid+1,qr)-(col_1[lc]==col_0[rc]);
}
//EndST
void dfs1(int x,int y)
{
	dep[x]=dep[y]+1;fa[x]=y;siz[x]=1;
	for(unsigned int i=0;i<G[x].size();++i)
	{
		if(G[x][i]==y)continue;
		dfs1(G[x][i],x);
		siz[x]+=siz[G[x][i]];
		if(siz[G[x][i]]>siz[hson[x]])hson[x]=G[x][i];
	}
}
void dfs2(int x,int y)
{
	top[x]=y;dfn[x]=++dfsTime;
	col[dfsTime]=tmp[x];
	if(siz[x]==1)return;
	dfs2(hson[x],y);
	for(unsigned int i=0;i<G[x].size();++i)
	{
		if(G[x][i]==fa[x]||G[x][i]==hson[x])continue;
		dfs2(G[x][i],G[x][i]);
	}
}
void set(int x,int y,int c)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		update(1,1,n,dfn[top[x]],dfn[x],c);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	update(1,1,n,dfn[y],dfn[x],c);
}
int get(int x,int y)
{
	int res=0,nowx=-1,nowy=-1;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y),swap(nowx,nowy);
		l_0=INF;r_1=-INF;
		res+=query(1,1,n,dfn[top[x]],dfn[x]);
		if(c_1==nowx)--res;
		nowx=c_0;
		x=fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y),swap(nowx,nowy);
	l_0=INF;r_1=-INF;
	res+=query(1,1,n,dfn[y],dfn[x]);
	cout<<c_0<<"!"<<nowy<<endl;
	if(c_1==nowx)--res;
	if(c_0==nowy)--res;
	return res;
}
int main()
{
	memset(lazy,-1,sizeof lazy);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",tmp+i);
	char q[5];
	int u,v,c;
	for(int i=1;i!=n;++i)
	{
		scanf("%d%d",&u,&v);
		G[u].push_back(v);
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,n);
	while(m--)
	{
		scanf("%s%d%d",q,&u,&v);
		if(q[0]=='Q')printf("%d\n",get(u,v));
		else
		{
			scanf("%d",&c);
			set(u,v,c);
		}
	}
	return 0;
}
